0ï¸âƒ£ Application startup (important groundwork)

Before any HTTP request happens, Spring Boot does this:

Detects spring-security on the classpath

Finds your SecurityFilterChain bean

Disables default security

Builds a filter chain like this (simplified):

SecurityContextHolderFilter
â†“
CustomAuthenticationFilter   â† your filter (inserted here)
â†“
UsernamePasswordAuthenticationFilter (replaced)
â†“
AuthorizationFilter
â†“
ExceptionTranslationFilter
â†“
...


ğŸ‘‰ Because you used:

.addFilterAt(customAuthenticationFilter,
    UsernamePasswordAuthenticationFilter.class)


You replaced the standard username/password login mechanism.

1ï¸âƒ£ Client sends an HTTP request

Example request:

GET /api/data
key: 12345


No session, no login form, no JWT â€” just a raw HTTP request with a header.

2ï¸âƒ£ Request enters Spring Security filter chain

Spring Security intercepts every request because of:

.anyRequest().authenticated()


So authentication must succeed, or access is denied.

3ï¸âƒ£ CustomAuthenticationFilter runs (OncePerRequestFilter)

Your filter executes once per request.

3.1 Extract authentication data
String key = String.valueOf(request.getHeader("key"));


This is your credential source
ğŸ‘‰ analogous to username/password, but simpler.

3.2 Create an unauthenticated Authentication object
CustomAuthentication ca =
    new CustomAuthentication(false, key);


Key ideas here:

Property	Meaning
false	Not authenticated yet
key	Credential to be verified

âš ï¸ At this moment:

This object is NOT trusted

Spring Security treats it as a request to authenticate

4ï¸âƒ£ Delegate to CustomAuthenticationManager
var a = customAuthenticationManager.authenticate(ca);


This is the authentication hand-off point.

Your filter:

Does NOT validate credentials

Does NOT know rules

Just delegates

ğŸ‘ This separation is exactly how Spring Security is designed

5ï¸âƒ£ CustomAuthenticationManager.authenticate()
if (customAuthenticationProvider.supports(authentication.getClass())) {
    return customAuthenticationProvider.authenticate(authentication);
}


What happens here:

Manager checks:

â€œDo I have a provider that understands this Authentication type?â€

Your provider supports:

CustomAuthentication.class


Manager forwards the request

If no provider supports it â†’ âŒ BadCredentialsException

6ï¸âƒ£ CustomAuthenticationProvider.authenticate()

This is the real authentication logic.

6.1 Cast Authentication
CustomAuthentication customAuthentication =
    (CustomAuthentication) authentication;


Safe because supports() already checked the type.

6.2 Extract the credential
String headerKey = customAuthentication.getKey();

6.3 Compare with server-side secret
@Value("${our.very.very.sercret.key}")
private String key;


Then:

if (key.equals(headerKey)) {
    return new CustomAuthentication(true, null);
}


âœ”ï¸ Match â†’ authenticated
âŒ No match â†’ exception

6.4 Return an authenticated Authentication object

This is crucial:

return new CustomAuthentication(true, null);


Rules:

isAuthenticated() must return true

This object represents a trusted identity

Think of it as:

â€œYes, this request is legit. I vouch for it.â€

7ï¸âƒ£ Control returns to CustomAuthenticationFilter

Back in the filter:

if (a.isAuthenticated()) {
    SecurityContextHolder.getContext().setAuthentication(a);
    filterChain.doFilter(request, response);
}

7.1 Store Authentication in SecurityContext

This is the single most important line:

SecurityContextHolder.getContext().setAuthentication(a);


Now:

Spring Security considers the request authenticated

The authentication is available everywhere:

Controllers

Method security

Authorization checks

7.2 Continue filter chain
filterChain.doFilter(request, response);


If you donâ€™t call this, request processing stops here.

8ï¸âƒ£ Authorization phase kicks in

Later in the chain:

.anyRequest().authenticated()


Spring Security checks:

SecurityContextHolder.getContext().getAuthentication()


âœ”ï¸ Present
âœ”ï¸ isAuthenticated() == true

â¡ï¸ Access granted

9ï¸âƒ£ Controller executes normally

Your controller method is now called.

From Springâ€™s perspective:

Authentication already happened

No difference from form login / JWT / OAuth

ğŸ”Ÿ What happens on failure?
Case 1: Wrong key

Provider throws:

throw new BadCredentialsException("Bad credentials");


Spring Security:

Clears SecurityContext

Triggers ExceptionTranslationFilter

Returns 401 Unauthorized

Case 2: Missing header

request.getHeader("key") == null
â†’ comparison fails
â†’ same 401 flow

âš ï¸ Important observations (very senior-level)
1ï¸âƒ£ Your filter does NOT handle failure explicitly

You do not call:

filterChain.doFilter(...)


on failure.

Thatâ€™s OK only because an exception is thrown.
But if you ever return null instead of throwing â†’ ğŸš¨ request will hang.

2ï¸âƒ£ You are doing stateless authentication

No sessions

No cookies

Every request must carry the key

Perfect for:

Internal services

Machine-to-machine APIs

3ï¸âƒ£ Why OncePerRequestFilter was the right choice

You were ğŸ’¯ correct not to use AuthenticationFilter because:

Youâ€™re not implementing a login endpoint

You donâ€™t need success/failure handlers

You want silent request-level authentication

This is exactly what OncePerRequestFilter is for.

ğŸ§  Mental model (remember this)
Request
 â†“
CustomAuthenticationFilter
 â†“
AuthenticationManager
 â†“
AuthenticationProvider
 â†“
SecurityContextHolder
 â†“
Authorization
 â†“
Controller